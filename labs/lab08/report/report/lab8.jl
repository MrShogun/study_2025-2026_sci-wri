using LinearAlgebra
function Print_Matrix(A::Matrix)
    for i in 1:size(A)[1]
        for j in 1:size(A)[2]
            print(A[i,j], " ")
        end
        println("\n")
    end
end
function Print_Vector(a::Vector)
    for i in 1:length(a)
        println(a[i])
    end
end

A = [1 2 -3; 2 4 0; 1 1 1]
println("Матрица A:")
Print_Matrix(A)
# Нахождение собственных значений и векторов
eigvals, eigvecs = eigen(A)

# Отображение результатов
println("Собственные значения матрицы A:")
Print_Vector(eigvals)
println("Собственные векторы матрицы A:")
Print_Matrix(eigvecs)

# Создание симметричной матрицы
C = A' * A

# Нахождение собственных значений и векторов симметричной матрицы
eigvals_sym, eigvecs_sym = eigen(C)

# Отображение результатов для симметричной матрицы
println("Собственные значения симметричной матрицы:")
Print_Vector(eigvals_sym)
println("Собственные векторы симметричной матрицы:")
Print_Matrix(eigvecs_sym)

# Цепи Маркова.
println("\nЦепи Маркова. Матрица вероятностных переходов T:")
T = [1 0.5 0 0 0; 0 0 0.5 0 0; 0 0.5 0 0.5 0; 0 0 0.5 0 0; 0 0 0 0.5 1]
a = [0.2; 0.2; 0.2; 0.2; 0.2]
b = [0.5; 0; 0; 0; 0.5]
c = [0; 1; 0; 0; 0]
d = [0; 0; 1; 0; 0]
Print_Matrix(T)
# Вероятностное распределение состояний через 5 шагов
println("\nНачальное состоение: a = $(a)")
println("Вероятностное распределение состояний через 5 шагов: ", T^5 * a)
println("Начальное состоение: b = $(b)")
println("Вероятностное распределение состояний через 5 шагов: ", T^5 * b)
println("Начальное состоение: c = $(c)")
println("Вероятностное распределение состояний через 5 шагов: ", T^5 * c)
println("Начальное состоение: d = $(d)")
println("Вероятностное распределение состояний через 5 шагов: ", T^5 * d)

# Равновесное состояние
println("\nРавновесное состояние. Матрица вероятностных переходов T:")
T = [0.48 0.51 0.14; 0.29 0.04 0.52; 0.23 0.45 0.34]
Print_Matrix(T)
# Нахождение собственных значений и векторов
eigvals, eigvecs = eigen(T)
println("Собственные значения матрицы T:")
Print_Vector(eigvals)
println("Собственные векторы матрицы T:")
Print_Matrix(eigvecs)
# Нормализация третьего собственного вектора 
# (соответствующего равновесному состоянию)
x = eigvecs[:,3] / sum(eigvecs[:,3])

# Проверка равновесного состояния
println("Равновесное состояние (третий нормированный собственный вектор): ")
Print_Vector(x)

# Проверка через умножение
println("T^10 * x: ", T^10 * x)
println("T^50 * x: ", T^50 * x)
println("T^50 * x - T^10 * x: ", T^50 * x - T^10 * x)